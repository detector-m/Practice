## 数据结构

[数据结构与算法教程]("http://data.biancheng.net/")

### 数据的存储结构

数据结构一般有顺序存储结构和链式存储结构。

1. 顺序存储结构：按顺序存储。如数组，栈，队列等。
2. 链式存储结构：通过链条一样连接在一起的存储方式。数据元素包含数据部分和地址部分，通过地址连接起来。

### 数据的逻辑结构

数据的逻辑结构：反映数据元素之间的逻辑关系的数据结构，逻辑关系是指数据元素之前的前后间的关系，与它们在计算机中存储的位置无关。逻辑结构包括：

1. 集合：数据结构中的元素之间除了同属一个集合的相互关系外，无其他关系。
2. 线性结构：数据结构中的元素一对一的相互关系。
3. 树形结构：一对多的关系。
4. 图形结构：多对多的相互关系（图形结构）。类似于我们人的交集关系。

### 链表

链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。易于增删、不易于查找。

* 单向链表：一个节点包含数据部分和向后指针部分， 从头到尾，一个接着一个，尾部节点的指针为空。就像火车那样。
* 双向链表：每个节点包含向前指针、向后指针、数据，首部节点的向前指针指向为空，尾部节点的向后指针为空。也是一个一个节点连接着，每个节点都有指向前一个节点和指向后一个节点的指针。
* 循环链表：链表连接为一个环。节点一个一个连接为一个环。

<span>判断链表是否有环：</span>

设定连个指针，slow，fast，快慢指针，每次分别前进1步，2步，如果有环slow和fast必然会相遇。

### 数组与链表区别

* 数组：存放的元素在内存上是连续，可以通过下表查找。插入删除需要移动元素。适合有序的查找。
* 链表：存放的元素在内存上是不连续的，查找慢，增删快。

### 栈、队列和堆

* 栈：限定尾部进行插入和删除操作。我们把允许插入、删除的一段称为栈顶，另一段则为栈底。是一种先进后出的数据结构。向栈顶插入数据称为压栈，从栈顶删除数据称为出栈。自动变量的定义。

* 队列：允许一端进行插入操作，而另一段进行删除操作的线性链表。允许插入的一端称为队尾，允许删除的一端称为队头。队列是一种先进先出的数据结构。

* 堆：一种经过排序的树形数据结构，堆通常是一个可以被看做一棵完全二叉树的数组对象。堆要满足两个性质：

	1. 堆中的节点总是不大于或不小于父节点。
	2. 堆总是一颗完全二叉树。

堆分为大堆和小堆。根节点最大的叫大堆，反之为小堆。但对于左右结点的大小则没有规定谁大谁小。

堆常用来实现优先队列，堆的存取是随意的。

堆的示例：[数据结构：堆（Heap）]("https://www.jianshu.com/p/6b526aa481b1")

```
// 来自数组的树
[ 10, 7, 2, 5, 1 ]
// 如果 i 是节点的索引，那么下面的公式就给出了它的父节点和子节点在数组中的位置：
parent(i) = floor((i - 1)/2)
left(i)   = 2i + 1
right(i)  = 2i + 2

// right(i) 就是简单的 left(i) + 1。左右节点总是处于相邻的位置。
// 根节点(10)没有父节点，因为 -1 不是一个有效的数组索引。同样，节点 (2)，(5)和(1) 没有子节点，因为这些索引已经超过了数组的大小，所以我们在使用这些索引值的时候需要保证是有效的索引值。
```

### 树

树：一种非线性存储结构。存储的是“一对多关系”的数据元素的集合。

二叉树：满足下面条件的就是二叉树
	
1. 本身是有序树；
2. 树中各个节点的度不查过2；

满二叉树：如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。

完全二叉树：二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。n个结点的完全二叉树的深度为 ⌊log2n⌋+1。
 
 对于任意一个完全二叉树来说，如果将含有的节点按照层次从左到右依次标号(1,2,3,4,5,6)，第一个从1开始,对于任意一个节点，完全二叉树还有一下性质：
 
 1. 第i个节点，其父节点为⌊i/2⌋。如果为0则没有父节点。
 2. 如果(2 * i)>n（总节点的个数），则节点i没有左孩子。否则其左孩子节点是(2 * i).
 3. 如果(2 * i + 1)>n（总节点的个数），则节点i没有右孩子，否则右孩子节点为(2 * i + 1)。

平衡二叉树：任意节点的子树的高度差（深度差）都小于等于1。

#### 二叉树的遍历

从根节点出发，依次遍历各节点。

* 先序遍历

	1. 访问根节点；
	2. 访问当前节点的左子树；
	3. 若当前节点无左子树，则访问当前节点的右子树。

* 中序遍历

	1. 访问当前节点的左子树；
	2. 访问根节点；
	3. 访问当前节点的右子树；

* 后序遍历

	1. 访问当前节点的左子树；
	2. 访问当前节点的右子树；
	3. 访问根节点。

#### 树的深度

1. 如果一棵树只有一个结点，它的深度为1。
2. 如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加1；同样如果根结点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1。
3. 如果既有右子树又有左子树，那该树的深度就是其左、右子树深度的较大值再加1。

```
struct TreeNode {
	int value;
	TreeNode *pLeft;
	TreeNode *pRight;
}

// 树的深度
int treeDepth(TreeNode *pRoot) {
	if (pRoot == NULL) {
		return 0;
	}
	
	int left = treeDepth(pRoot->pLeft) + 1;
	int right = treeDepth(pRoot->pRight) + 1;
	
	return left > right ? left : right;
}

// 是否是平衡二叉树

bool isBalancedTree(TreeNode *pRoot) {
	if (PRoot == NULL) {
		return true;
	}
	
	int left = treeDepth(pRoot->pLeft);
	int right = treeDepth(pRoot->pRight);
	
	int diff = left - right;
	if (diff > 1 || diff < -1) {
		return false;
	}
	
	return isBalancedTree(pRoot->pLeft) && isBalancedTree(pRoot->pRight);
}
```

